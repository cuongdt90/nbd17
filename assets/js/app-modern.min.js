/* nbdesignerjs
 * @author  netbaseteam
 * @link https://cmsmart.net
 * @version 1.9.0
 * @created Jun 2016
 * @modified 23, May 2018
 * */
var nbdApp = angular.module('nbd-app', ["angularSpectrumColorpicker"]);
nbdApp.constant("_", window._);
nbdApp.controller('designCtrl', ['$scope', 'FabricWindow', '$window', 'NBDDataFactory', 'filterFontFilter', 'filterArtFilter', '$timeout', '$http', 
    function($scope, FabricWindow, $window, NBDDataFactory, filterFontFilter, filterArtFilter, $timeout, $http){
    $scope.stages = [
        {
            config: {
                width: checkMobileDevice() ? 200: 400,
                height: checkMobileDevice() ? 200: 300,
                background: '#fff'
            },
            states: {},
            undos: [],
            redos: [],
            canvas: {}
        },       
        {
            config: {
                width: checkMobileDevice() ? 200: 300,
                height: checkMobileDevice() ? 200: 400,
                background: '#404762'
            },
            states: {},
            undos: [],
            redos: [],            
            canvas: {}
        }      
    ];
    $scope.defaultStageStates = {
        isActiveLayer: false,
        isLayer: false,
        isGroup: false,
        isText: false,
        isImage: false,
        isPath: false,
        isShape: false,
        isEditing: false,
        isRedoable: false,
        isUndoable: false,         
        boundingObject: {},
        coordinates: {},
        rotate: {},
        opacity: 100,
        snaplines: {},
        itemId: null,
        tempParameters: null,
        fontUsed: [{name: 'Roboto', alias: 'Roboto'}],
        type: null,
        text: {
            fontFamily: {
                alias: 'Roboto',
                r: 1,
                b: 1,
                i: 1,
                bi: 1
            },
            fontSize: 14,
            fontFamily: 'Roboto',
            textAlign: 'left',
            fontWeight: false,
            textDecoration: false,
            fontStyle: '',
            spacing: 0,
            lineHeight: 1.2,
            is_uppercase: false,
            fill: '#06d79c'
        }, 
        svg: {groupPath: {}, currentPath: null},
        image: {}
    };
    $scope.initSettings = function(){
        angular.copy(NBDESIGNCONFIG, $scope.settings);
        angular.extend($scope.settings, {
            showRule: true,
            showGrid: true,
            snapMode: true,
        });
        $scope.showTextColorPicker = false;
        $scope.__colorPalette = __colorPalette;
        $scope.currentColor = '#fff';
        $scope.listAddedColor = [];
        $scope.tempStageDesign = null;
        
        $scope.resource = {
            personal: {status: false, type: ''},
            webcam: {status: false},
            typography: {filter: {perPage: 20, currentPage: 1, total: 0}, data: [], init: true, onload: false},
            clipart: {filter: {perPage: 20, currentPage: 1, total: 0, currentCat: {}}, data: [], onload: false, init: true, filteredArts : []},
            font: {filter: {perPage: 10, currentPage: 1, total: 0}, data: [], filteredFonts : []},
            photo: {filter: {perPage: 20, currentPage: 1, total: 0, totalPage: 1}, data: [], init: true, onload: false, type: '', photoSearch: ''},
            dropbox: {filter: {perPage: 10, currentPage: 1, total: 0}, data: [], onload: false, init: true, filteredPhoto : []},
            facebook: {filter: {perPage: 10, currentPage: 1, total: 0}, data: [], onload: false, init: true, filteredPhoto : []},
            instagram: {filter: {perPage: 10, currentPage: 1, total: 0}, data: [], onload: false, init: true, token : ''}
        };
        $scope.includeExport = ['itemId', 'selectable', 'lockMovementX', 'lockMovementY','lockScalingX', 'lockScalingY', 'lockRotation', 'rtl', 'elementUpload', 'forceLock', 'isBg','is_uppercase','available_color','available_color_list','color_link_group','isOverlay'];
        
        $scope.resource.font.data = $scope.settings.fonts;
        $scope.resource.font.filter.total = $scope.resource.font.data.length;
        $scope.$watchCollection('resource.font.filter', function(newVal, oldVal){
            if(newVal.search != oldVal.search){
                $timeout(function() {
                    jQuery("#toolbar-font-familly-dropdown").stop().animate({
                        scrollTop: 0
                    }, 100);                    
                });
            }
            $scope.resource.font.filteredFonts = filterFontFilter($scope.resource.font.data, $scope.resource.font.filter);
        }, true);
        
        $scope.$watchCollection('resource.clipart.filter', function(newVal, oldVal){
            $scope.resource.clipart.filteredArts = filterArtFilter($scope.resource.clipart.data.arts, $scope.resource.clipart.filter);
            if(newVal.search != oldVal.search){
                $timeout(function() {
                    jQuery("#tab-svg .tab-scroll").stop().animate({
                        scrollTop: 0
                    }, 100);                    
                });
            }
            $scope.onEndRepeat('clipart');
        }, true);
    };
    $scope.addColor = function(){
        $scope.listAddedColor.push($scope.currentColor);
        $scope.listAddedColor = _.uniq($scope.listAddedColor);
    };
    $scope.hasGetUserMedia = function(){
        return !!(navigator.getUserMedia || navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia || navigator.msGetUserMedia);        
    };    
    $scope.settings = {};
    $scope.isModern = true;
    $scope.init = function() {
        $scope.initSettings();
        $scope.calcViewport();
        $scope.contextAddLayers = 'normal';
        $scope.workBenchHeight = $window.innerHeight;           
        $scope.workBenchWidth = $window.innerWidth;           
    };
    /* Util */
    $scope.generateUniqueId = function(){
        return '_' + Math.random().toString(36).substr(2, 9);
    };
    /* Get Data */
    $scope.getResource = function(type, container, callback){
        if( $scope.resource[type].data.length || angular.isUndefined($scope.resource[type].data.length) ) return;
        jQuery(container+' .loading-photo').show();
        NBDDataFactory.get('nbd_get_resource', {type: type}, function(data){
            jQuery(container+' .loading-photo').hide();
            var _data = JSON.parse(data);
            $scope.resource[type].data = _data.data; 
            $scope.resource[type].filter.total = $scope.resource[type].data.length;
            if( callback ) $scope.afterGetResource(type);
        });
    };
    $scope.getPhoto = function(type, context){
        $scope.resource.personal.status = false;
        if( $scope.resource.photo.type != type || context == 'search' ){
            $scope.resource.photo.data = [];
            $scope.resource.photo.filter.total = 0;
            $scope.resource.photo.filter.currentPage = 1;
            jQuery("#tab-photo .tab-scroll").stop().animate({
                scrollTop: jQuery('.main-items').height()
            }, 100);
            jQuery('#nbdesigner-gallery').css('height', 0);
        };
        $scope.resource.photo.type = type;
        if( $scope.resource.photo.type == '' ) return;
        jQuery('#tab-photo .loading-photo').show();
        if( $scope.resource.photo.filter.totalPage == 0 || $scope.resource.photo.filter.currentPage <= $scope.resource.photo.filter.totalPage ){       
            switch(type){
                case 'Pixabay':        
                    $http({
                        method: 'GET',
                        url: 'https://pixabay.com/api/?safesearch=true&key='+ NBDESIGNCONFIG['nbdesigner_pixabay_api_key'] +'&response_group=high_resolution&image_type=photo&per_page='+$scope.resource.photo.filter.perPage+'&page='+$scope.resource.photo.filter.currentPage+'&q='+encodeURIComponent($scope.resource.photo.photoSearch)
                    }).then(function successCallback(response) {
                        var data = response.data,
                        totalPage = Math.ceil(data.totalHits/$scope.resource.photo.filter.perPage);
                        $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                        _.each(data.hits, function(val, key) {
                            $scope.resource.photo.data.push({
                                extenal: 1,
                                link: angular.isDefined(val.fullHDURL) ? val.fullHDURL : ( angular.isDefined(val.largeImageURL) ? val.largeImageURL : val.imageURL ),
                                preview: val.previewURL,
                                des: '@ ' +val.user
                            });
                        });
                        $scope.afterGetResource('photo');
                    }, function errorCallback(response) {
                        console.log('Pixabay');
                        jQuery('#tab-photo .loading-photo').hide();
                    });            
                    break;
                case 'Unsplash': 
                    var url = $scope.resource.photo.photoSearch != '' ? 'https://api.unsplash.com/search/photos/?client_id='+ NBDESIGNCONFIG['nbdesigner_unsplash_api_key'] +'&per_page='+$scope.resource.photo.filter.perPage+'&page='+$scope.resource.photo.filter.currentPage+'&query='+encodeURIComponent($scope.resource.photo.photoSearch) : 'https://api.unsplash.com/photos/?client_id='+ NBDESIGNCONFIG['nbdesigner_unsplash_api_key'] +'&per_page=20&page=1&order_by=latest';
                    $http({
                        method: 'GET',
                        url: url
                    }).then(function successCallback(response) {
                        var data = response.data;
                        if( $scope.resource.photo.photoSearch != '' ){
                            $scope.resource.photo.filter.totalPage = data.total_pages > 10 ? 10 : data.total_pages;
                            var results = data.results;
                        }else{
                            $scope.resource.photo.filter.totalPage = 10;
                            var results = data;
                        }
                        _.each(results, function(val, key) {
                            $scope.resource.photo.data.push({
                                extenal: 1,
                                link: val.urls.raw,
                                preview: val.urls.thumb,
                                des: '@ '+val.user.name
                            });
                        });
                        $scope.afterGetResource('photo');
                    }, function errorCallback(response) {
                        console.log('Unsplash');
                        jQuery('#tab-photo .loading-photo').hide();
                    }); 
                    break;
            }  
        };    
        $scope.updateApp();   
    };
    $scope.getPersonalPhoto = function(type, files){
        jQuery('#tab-photo .loading-photo').show();
        switch(type){
            case 'dropbox':
                _.each(files, function(file, index){
                    $scope.resource.dropbox.data.push({
                        extenal: 1,
                        id :  file.id,
                        preview :  file.link,
                        link :  file.link,
                        des: file.name
                    });
                });    
                $scope.resource.dropbox.data = _.uniqBy($scope.resource.dropbox.data, 'id');
                $scope.resource.dropbox.filter.total = $scope.resource.dropbox.data.length;
                break;
            case 'instagram':
                var endpointUrl = 'https://api.instagram.com/v1/users/self/media/recent?access_token='+$scope.resource.instagram.token;
                $http({method: 'GET', url: endpointUrl}).then(function successCallback(response) {
                    _.each(response.data.data, function(file, index){
                        $scope.resource.instagram.data.push({
                            extenal: 1,
                            id :  file.id,
                            preview :  file.images.thumbnail.url,
                            link :  file.images.standard_resolution.url,
                            des: file.user.full_name
                        });
                    }); 
                    $scope.resource.instagram.data = _.uniqBy($scope.resource.instagram.data, 'id');
                    $scope.resource.instagram.filter.total = $scope.resource.instagram.data.length;
                }, function errorCallback(response) {
                    console.log('loadInstagramPhotos');
                    jQuery('#tab-photo .loading-photo').hide();
                });                
                break
        }
    };
    $scope.authenticateInstagram = function(){
        $scope.resource.instagram.token = sessionStorage.getItem('nbd_instagram_token');
        if( $scope.resource.instagram.token  ){
            $scope.getPersonalPhoto('instagram');
        }else{
            var popupLeft = (window.screen.width - 700) / 2,
                    popupTop = (window.screen.height - 500) / 2;  
            var url = 'https://instagram.com/oauth/authorize/?client_id='+NBDESIGNCONFIG['nbdesigner_instagram_app_id']+'&redirect_uri='+NBDESIGNCONFIG['instagram_redirect_uri']+'&response_type=token';
            var popup = window.open(url, '_blank', 'width=700,height=500,left='+popupLeft+',top='+popupTop+'');
            popup.onload = new function() {
                if(window.location.hash.length == 0) {
                    popup.open(url, '_self');
                };
                var interval = setInterval(function () {
                    try {
                        if (popup.location.hash.length) {
                            clearInterval(interval);
                            $scope.resource.instagram.token = popup.location.hash.slice(14);
                            sessionStorage.setItem('nbd_instagram_token', $scope.resource.instagram.token);
                            popup.close();
                            $scope.getPersonalPhoto('instagram');
                        }
                    } catch (evt) {
                        console.log('Instagram');
                        alert('Try again!');
                    }
                }, 100);            
            }            
        }
    };
    $scope.logoutInstagram = function(){
        sessionStorage.removeItem('nbd_instagram_token');
        $scope.resource.instagram.token = '';
        $scope.resource.instagram.data = [];
        $scope.resource.instagram.filter.currentPage = 1;
        $scope.resource.instagram.filter.total = 0;
        jQuery("#tab-photo .tab-scroll").stop().animate({
            scrollTop: jQuery('.main-items').height()
        }, 100);        
    };
    $scope.afterGetResource = function(type){
        switch(type){
            case 'clipart':
                _.each($scope.resource.clipart.data.cat, function(cat, key) {
                    cat.amount = 0;
                    _.each($scope.resource.clipart.data.arts, function(art, k) {
                        art.url = art.url.indexOf("http") > -1 ? art.url : NBDESIGNCONFIG['art_url'] + art.url;
                        if (art.cat.length == 0) art.cat = ["0"];
                        if ( _.includes(art.cat, cat.id) ) cat.amount++
                    });
                }); 
                $scope.resource.clipart.filter.currentCat = $scope.resource.clipart.data.cat[0];
                $scope.resource[type].filter.total = $scope.resource.clipart.filter.currentCat.amount;
                jQuery('#tab-svg').removeClass('nbd-onload');
                break;
            case 'photo':
                if( $scope.resource.photo.data.length == 0 ) jQuery('#tab-photo .loading-photo').hide();
                $scope.resource.photo.filter.total = $scope.resource.photo.filter.totalPage * $scope.resource.photo.filter.perPage;            
                break;
        }
    };
    $scope.changeCat = function(type, cat){
        $scope.resource[type].filter.search = '';
        $scope.resource[type].filter.currentPage = 1;
        $scope.resource[type].filter.currentCat = cat;
        $scope.resource[type].filter.total = cat.amount;
        $scope.updateApp();
        switch(type){
            case 'clipart':
                jQuery("#tab-svg .tab-scroll").stop().animate({
                    scrollTop: 0
                }, 100);
            break;
        };        
    };
    $scope.getProduct = function(){
        //todo something
    };    
    /* Webcam */
    $scope.initWebcam = function(){
        $scope.resource.webcam.status = true;
        Webcam.set({
            width: 400,
            height: 300,
            dest_width: 1280,
            dest_height: 960,
            image_format: 'jpeg',
            jpeg_quality: 100
        });                            
        Webcam.attach( '#my_camera' );     
        Webcam.setSWFLocation(NBDESIGNCONFIG['assets_url'] + 'webcam.swf');  
    };    
    $scope.pauseWebcam = function(status){
        status == true  && Webcam.freeze() || Webcam.unfreeze();
    };
    $scope.resetWebcam = function(){
        if($scope.resource.webcam.status){
            Webcam.reset();
            $scope.resource.webcam.status = false;
        }else{
            $scope.initWebcam();
        }        
    };     
    $scope.takeSnapshot = function(){
        Webcam.snap( function(data_uri) {
            $scope.resetWebcam();
            var raw_image_data = data_uri.replace(/^data\:image\/\w+\;base64\,/, '');
            NBDDataFactory.get('nbdesigner_save_webcam_image', {image: raw_image_data}, function(data){
                data = JSON.parse(data);
                if(data.flag == 'success'){
                    jQuery('.popup-webcam .close-popup').triggerHandler('click');
                }else{
                    
                }
            });
        });
    };
    $scope.onEndRepeat = function(type){
        switch(type){
            case 'typography':
                $scope.renderMasonryList(type, '.nbd-sidebar .typography-items', '.typography-item', '#tab-typography', $scope.resource[type].init);
                break;
            case 'font':
                //todo something
                break;
            case 'clipart':
                $scope.renderMasonryList(type, '#tab-svg .clipart-wrap', '.clipart-item', '#tab-svg', $scope.resource[type].init);
                break; 
            case 'photo':
                $scope.renderMasonryList(type, '#tab-photo .nbdesigner-gallery', '.nbdesigner-item', '#tab-photo', $scope.resource[type].init);
                break;
            case 'dropbox':
                $scope.renderMasonryList(type, '#nbd-dropbox-wrap .mansory-wrap', '.mansory-item', '#nbd-dropbox-wrap', $scope.resource[type].init);
                break;  
            case 'instagram':
                $scope.renderMasonryList(type, '#nbd-instagram-wrap .mansory-wrap', '.mansory-item', '#nbd-instagram-wrap', $scope.resource[type].init);
                break;            
        }
    };
    $scope.renderMasonryList = function(type, container, item, scrollContainer, init){       
        imagesLoaded( jQuery(container), function() {
            if( !init ) jQuery(container).masonry('destroy');
            jQuery(container).masonry({
                itemSelector: item
            });
            jQuery.each(jQuery(container + ' ' +item), function(e) {
                var animate = Math.floor(Math.random() * 10);
                animate = (animate + 1) * 100;           
                if( checkMobileDevice() ){
                    jQuery(this).addClass("in-view");
                }else{
                    jQuery(this).addClass("in-view slideInDown animated animate"+animate);
                }
            });
            $timeout(function() {
                jQuery(scrollContainer+' .tab-scroll').perfectScrollbar('update');
            });
            jQuery(scrollContainer + ' .loading-photo').hide();
            $scope.resource[type].onload = false;
            $scope.resource[type].init = false;
        });
    };
    $scope.scrollLoadMore = function(container, type){
        if( $scope.resource[type].onload ) return;
        if( type == 'photo' && $scope.resource.personal.status ){
            var photoType = $scope.resource.personal.type;
            if( $scope.resource[photoType].filter.currentPage * $scope.resource[photoType].filter.perPage < $scope.resource[photoType].filter.total ){
                $scope.resource[photoType].filter.currentPage += 1;
            }else{
                jQuery(container + ' .loading-photo').hide();
                return;
            }
            jQuery(container + ' .loading-photo').show();
            $scope.resource[photoType].onload = true;
            $scope.updateApp();
            return;
        };
        if( $scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage >= $scope.resource[type].filter.total){
            jQuery(container + ' .loading-photo').hide();
            return;
        }
        jQuery(container + ' .loading-photo').show();
        if( $scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage < $scope.resource[type].filter.total ){
            $scope.resource[type].filter.currentPage += 1;
        }
        switch(type){
            case 'typography':
            case 'clipart':    
                $scope.resource[type].onload = true;
                break;
            case 'font':
                //todo something
                break;  
            case 'photo':
                $scope.resource[type].onload = true;
                !$scope.resource.personal.status && $scope.getPhoto($scope.resource.photo.type, 'more');
                break;             
                
        }
        $scope.updateApp();
    };
    $scope.generateTypoLink = function(typo){
        return NBDESIGNCONFIG['plg_url'] + '/data/typography/img/' + typo.id + '.png';
    };
    /* Fonts */

    $scope.loadFontFailAction = function( font ){
        _.remove($scope.settings.gg_fonts, {
            id: font.id
        });
        $scope.resource.font.filteredFonts = filterFontFilter($scope.resource.font.data, $scope.resource.font.filter);
        $scope.updateApp();
    };
    /* Save Data */
    $scope.updateApp = function(){
        if ($scope.$root.$$phase !== "$apply" && $scope.$root.$$phase !== "$digest") $scope.$apply(); 
    };
    $scope.$on('nbd:keypress', function(event, e){
        $scope.keypressHandle(e);
    });
    $scope.$on('nbd:keydown', function(event, e){
        $scope.keydownHandle(e);
    });    
    $scope.keydownHandle = function(e){
        //todo
    };
    $scope.wraperClickHandle = function($event){
        var $textPicker = jQuery('#nbd-text-color-picker');
        if (!jQuery($event.target).hasClass('color-palette-add') && $scope.showTextColorPicker 
                && $textPicker.has($event.target).length == 0 && !$textPicker.is($event.target)){
            $scope.showTextColorPicker = false;
        };
    };
    $scope.keypressHandle = function(e){
        var targetEl = e.target.tagName.toUpperCase();
        if( targetEl == 'INPUT' || targetEl == 'TEXTAREA' ||  $scope.stages[$scope.currentStage].states.isEditing ) return;        
        if(e.ctrlKey || e.metaKey){
            var keepDefault = [67, 86, 116];
            if( _.includes(keepDefault, e.which) ) return;
            e.preventDefault();
        }else if( e.altKey ){
            e.preventDefault();
            switch( e.which ) {
                case 37:
                    /* Hold Alt press left arrow */
                    $scope.moveLayer('left', 'alt');
                    break;
                case 38:
                    /* Hold Alt press up arrow */
                    $scope.moveLayer('up', 'alt');
                    break;       
                case 39:
                    /* Hold Alt press right arrow */
                    $scope.moveLayer('right', 'alt');
                    break;
                case 40:
                    /* Hold Alt press down arrow */
                    $scope.moveLayer('down', 'alt');
                    break;                       
            } 
        } else if( e.shiftKey ){

        } else {
            switch( e.which ) {
                case 37:
                    /* Press left arrow */
                    $scope.moveLayer('left');
                    break;
                case 38:
                    /* Press up arrow */
                    $scope.moveLayer('up');
                    break;       
                case 39:
                    /* Press right arrow */
                    $scope.moveLayer('right');
                    break;
                case 40:
                    /* Press down arrow */
                    $scope.moveLayer('down');
                    break; 
                    
            }
        }
        //}
    };  
    $scope.onClickStage = function( $event ){
        /*
         * Deactive all layer if click outer canvas 
         * Hide context menu
         */
        
        if(angular.element($event.target).hasClass('stage')){
            $scope.deactiveAllLayer();
        }
        $scope.ctxMenuStyle.visibility = 'hidden';
        $scope.updateApp();
    };    
    $scope.$on('nbd:contextmenu', function(event, e){
        $scope.contextMenu(e);
    });
    $scope.ctxMenuStyle = {
        'top': '17%',
        'left': '33%',
        'visibility': 'hidden'
    };
    $scope.contextMenu = function(e){
        if( $scope.stages[$scope.currentStage].states.isEditing ) return;
        e.preventDefault();
        if($scope.stages[$scope.currentStage].states.isActiveLayer){
            var posX = e.pageX,
                posY = e.pageY;
            var contextEl = angular.element(document.getElementById('nbd-context-menu'))[0],
                height = contextEl.clientHeight,
                width = contextEl.clientWidth; 
            if($scope.workBenchWidth < (posX + width + 15)) posX = $scope.workBenchWidth - width - 15;
            if($scope.workBenchHeight < (posY + height + 15)) posY = $scope.workBenchHeight - height - 15;       
            $scope.ctxMenuStyle = {
                'visibility': 'visible',
                top: posY,
                left: posX
            }
        }else{
            $scope.ctxMenuStyle = {
                'visibility': 'hidden',
                'pointer-events': 'none'
            };
        }
        $scope.updateApp();
    }; 
    $scope.$on('canvas:created', function(event, id){
        $scope.initStageSetting( id );
        var _canvas = $scope.stages[id].canvas;
        
        _canvas.selectionColor = "rgba(1, 196, 204, 0.3)";
        _canvas.selectionBorderColor= "#01c4cc";
        _canvas.selectionLineWidth= 0.5;
        
        _canvas.on('mouse:down', function(options) {
            $scope.onMouseDown(id, options);
        });
        _canvas.on("mouse:over", function(options){
            $scope.onMouseOverStage(id, options);
        });
        _canvas.on("mouse:out", function(options){
            $scope.onMouseOutStage(id, options);
        });
        _canvas.on("mouse:move", function(options){
            $scope.onMouseMoveStage(id, options);
        });        
        _canvas.on("mouse:up", function(options){
            $scope.onMouseUpStage(id, options);
        });
        _canvas.on("path:created", function(options){
            $scope.onPathCreated(id, options);
        });
        _canvas.on("object:added", function(options){
            $scope.onObjectAdded(id, options);
        });
        _canvas.on("selection:created", function(options){
            $scope.onSelectionCreated(id, options);
        });
        _canvas.on("object:scaling", function(options){
            $scope.onObjectScaling(id, options);
        });
        _canvas.on("object:moving", function(options){
            $scope.onObjectMoving(id, options);
        });
        _canvas.on("object:rotating", function(options){
            $scope.onObjectRotating(id, options);
        });
        _canvas.on("object:modified", function(options){
            $scope.onObjectModified(id, options);
        });
        _canvas.on("before:render", function(options){
            $scope.onBeforeRender(id, options);
        });
        _canvas.on("after:render", function(options){
            $scope.onAfterRender(id, options);
        });
        _canvas.on("selection:cleared", function(options){
            $scope.onSelectionCleared(id, options);
        });
        _canvas.on("text:editing:entered", function(options){
            $scope.onEditingEntered(id, options);
        });   
        _canvas.on("selection:updated", function(options){
            $scope.onSelectionUpdated(id, options);
        });        
        _canvas.on("text:selection:changed", function(options){
            $scope.onSelectionChanged(id, options);
        });
    });   
    $scope.calcViewport = function(){
        //console.log(jQuery('.nbd-stages').width() +'--'+ jQuery('.nbd-stages').height());
        
    };
    $scope.initStageSetting = function( id ){
        var _canvas = $scope.stages[id]['canvas'];
        $scope.setStageDimension(id);
        angular.copy($scope.defaultStageStates, $scope.stages[id].states);
        _canvas.controlsAboveOverlay = true;
        _canvas.calcOffset().renderAll();
        $scope.updateApp();
    };
    $scope.addStage = function(){
        $scope.stages.push({canvas: {}});
    }; 
    $scope.setStageDimension = function(id){
        var currentWidth = $scope.stages[id].config.width,
            currentHeight = $scope.stages[id].config.height;
        $scope.stages[id]['canvas'].setDimensions({'width' : currentWidth, 'height' : currentHeight});
    };     
    $scope.switchStage = function(id, command){
        var idCurrentStage = 'stage-container-' + id,
            next =  parseInt(id) + 1;   
        if(command == 'prev')  {
            next  = parseInt(id) - 1;
        }
        if($scope.isModern){
            var idNextStage = 'stage-container-' + next;
            var currentStage = angular.element(document.getElementById(idCurrentStage)),
                nextStage = angular.element(document.getElementById(idNextStage));
            currentStage.addClass('animated');    
            currentStage.removeClass('fadeInUp');
            currentStage.removeClass('fadeInDown');  
            nextStage.addClass('animated');
            nextStage.removeClass('hidden');            
            nextStage.removeClass('fadeOutDown');            
            nextStage.removeClass('fadeOutUp');            
            if(command == 'prev'){
                currentStage.removeClass('fadeOutDown');
                currentStage.addClass('fadeOutUp');    
                nextStage.addClass('fadeInDown');                 
            }else {
                currentStage.removeClass('fadeOutUp');
                currentStage.addClass('fadeOutDown');    
                nextStage.addClass('fadeInUp');                 
            }; 
        }
        $scope.currentStage = next;
    };
    $scope.onMouseDown = function(id, options){    
        //angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'}); 
        $scope.updateApp();
    };
    $scope.onMouseOverStage = function(id, options){
        var item = options.target;
        $scope.updateBoundingRect(item);
        $scope.updateApp();
    };   
    $scope.onMouseOutStage = function(id, options){
        if(options.target){  
            angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'}); 
        }       
        $scope.updateApp();
    }; 
    $scope.onMouseMoveStage = function(id, options){

        
    };   
    $scope.onMouseUpStage = function(id, options){
        var _stage = $scope.stages[$scope.currentStage];
        /*
         * Hide bounding rect, coordinates label, snap lines, rotate label
         */
        angular.merge(_stage.states.boundingObject, {visibility: 'hidden'});
        angular.merge(_stage.states.coordinates, {style: {visibility: 'hidden'}}); 
        var position = {
            ht: {top: -9999},
            hb: {top: -9999},
            hc: {top: -9999},
            vl: {left: -9999},
            vr: {left: -9999},
            vc: {left: -9999},
            hcc: {top: -9999},
            vcc: {left: -9999},
            vel: {left: -9999},
            ver: {left: -9999},
            het: {top: -9999},
            heb: {top: -9999}
        };        
        angular.merge(_stage.states.snaplines, position);
        angular.merge(_stage.states.rotate, {style: {visibility: 'hidden'}});
        
        /* get layer parameters before modify */
        var _canvas = _stage.canvas,
            objects =  _canvas.getActiveObjects();  
        //todo with group    
        _stage.tempParameters = null;
        if( objects.length == 1 ){
            _stage.tempParameters = JSON.stringify(objects[0].toJSON());
        }
        
        $scope.updateApp(); 
    };  
    $scope.beforeObjectModify = function( item ){
        $scope.setHistory({
            element: item,
            parameters: JSON.stringify(item.toJSON()),
            interaction: 'modify'
        });         
    };
    $scope.onPathCreated = function(id, options){
        
    };   
    $scope.onObjectAdded = function(id, options){
        var _canvas = this.stages[$scope.currentStage]['canvas'],
        item = options.target,   
        d = new Date(),
        itemId = d.getTime() + Math.floor(Math.random() * 1000);
        if( $scope.contextAddLayers == 'normal' || $scope.contextAddLayers == 'copy' || $scope.contextAddLayers == 'template' ){
            item.set({"itemId" : itemId});
        };
        if( $scope.contextAddLayers == 'normal' ){
            _canvas.viewportCenterObject(item);
        }
        item.setCoords();
        var top = item.get('top'),
            left = item.get('left');
        if( $scope.contextAddLayers == 'normal' ){
            item.set({top: top - 50});
            item.animate('top', top, {
                duration: 400,
                onChange: function(){
                    $scope.renderStage();
                },
                onComplete: function(){
                    _canvas.setActiveObject(item); 
                    $scope.setHistory({
                        element: item,
                        parameters: JSON.stringify(item.toJSON()),
                        interaction: 'add'
                    });   
                    $scope.stages[$scope.currentStage].tempParameters = JSON.stringify(item.toJSON());                    
                    $scope.renderStage();       
                },
                easing: FabricWindow.util.ease['easeInQuad']
            });  
            $scope.stages[$scope.currentStage].states.isActiveLayer = true;
        }else if( $scope.contextAddLayers == 'copy' ){
            item.set({top: top - 20, left: left - 20});
            item.animate({'top': top, 'left': left}, {
                duration: 400,
                onChange: function(){
                    $scope.renderStage();
                },
                onComplete: function(){
                    $scope.setHistory({
                        element: item,
                        parameters: JSON.stringify(item.toJSON()),
                        interaction: 'add'
                    });   
                    $scope.stages[$scope.currentStage].tempParameters = JSON.stringify(item.toJSON());                    
                    $scope.renderStage();       
                },
                easing: FabricWindow.util.ease['easeInQuad']
            });             
        }else{
            $scope.renderStage();
        };
        $scope.contextAddLayers = 'normal';
        if( checkMobileDevice() ){
            jQuery('#design-tab').triggerHandler('click');
        };
    };  
    $scope.onObjectScaling = function(id, options){
        var item = options.target; 
        if(item) item.setCoords();
        $scope.updateCoordenatesLabel(item);
        $scope.updateBoundingRect(item);
        $scope.updateSnapLines();
        $scope.updateApp();
    };    
    $scope.onObjectMoving = function(id, options){
        var item = options.target; 
        if(item) item.setCoords();
        $scope.updateCoordenatesLabel(item);
        $scope.updateBoundingRect(item);
        $scope.updateSnapLines();
        $scope.updateApp();  
    }; 
    $scope.onObjectRotating = function(id, options){
        var item = options.target;
        if(item) item.setCoords();
        $scope.updateCoordenatesLabel(item);
        $scope.updateBoundingRect(item);
        $scope.updateSnapLines();
        $scope.updateAngleLabel(item);
        $scope.updateApp();         
    };   
    $scope.updateAngleLabel = function( item ){
        if(item){
            angular.merge($scope.stages[$scope.currentStage].states.rotate, {
                style: {
                    transform: "rotate("+item.angle+"deg)",
                    top: item.oCoords.mtr.y,
                    left: item.oCoords.mtr.x,
                    visibility: 'visible'                    
                },
                angle: fabric.util.toFixed(item.angle, 0)
            });
        }else{
            angular.merge($scope.stages[$scope.currentStage].states.rotate, {style: {visibility: 'hidden'}});   
        }
    };
    $scope.updateCoordenatesLabel = function(item){
        if(item){
            var bound = item.getBoundingRect();
            var top = item.oCoords.tl.y,
                left = item.oCoords.tl.x;
            if( (item.angle > 315 && item.angle < 360) || (item.angle > 45 && item.angle < 90) 
                    || (item.angle > 135 && item.angle < 180) || (item.angle > 225 && item.angle < 270) ){
                if( item.oCoords.tr.x < left ){
                    top = item.oCoords.tr.y;
                    left = item.oCoords.tr.x;
                }
                if( item.oCoords.br.x < left ){
                    top = item.oCoords.br.y;
                    left = item.oCoords.br.x;
                }   
                if( item.oCoords.bl.x < left ){
                    top = item.oCoords.bl.y;
                    left = item.oCoords.bl.x;
                }            
            }else{
                if( item.oCoords.tr.y < top ){
                    top = item.oCoords.tr.y;
                    left = item.oCoords.tr.x;
                }
                if( item.oCoords.br.y < top ){
                    top = item.oCoords.br.y;
                    left = item.oCoords.br.x;
                }   
                if( item.oCoords.bl.y < top ){
                    top = item.oCoords.bl.y;
                    left = item.oCoords.bl.x;
                }
            }
            angular.merge($scope.stages[$scope.currentStage].states.coordinates, {      
                style: {
                    visibility: 'visible',
                    top: top,
                    left: left                        
                },
                //todo something to recalculate real top, left
                top: parseInt(top),
                left: parseInt(left)
            });  
        }
    };
    $scope.updateBoundingRect = function(item){
        if(item){
            var bound = item.getBoundingRect();
            angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {
                visibility: 'visible',
                top: item.oCoords.tl.y - 1,
                left: item.oCoords.tl.x - 1,
                width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2 )) + 2,
                height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2 )) + 2,
                transform: "rotate("+item.angle+"deg)"
            });
        }else{
            angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});   
            angular.merge($scope.stages[$scope.currentStage].states.coordinates, {visibility: 'hidden'});   
        }
    };
    $scope.updateSnapLines = function(){
        var _canvas = this.stages[$scope.currentStage]['canvas'],
            item = _canvas.getActiveObject(),
            position = {
                ht: {top: -9999},
                hb: {top: -9999},
                hc: {top: -9999},
                vl: {left: -9999},
                vr: {left: -9999},
                vc: {left: -9999},
                hcc: {top: -9999},
                vcc: {left: -9999},
                vel: {left: -9999},
                ver: {left: -9999},
                het: {top: -9999},
                heb: {top: -9999}                
            };
        if( item ){
            var bound = item.getBoundingRect();
            _canvas.forEachObject(function(obj) {
                if( obj === item ) return;
                var _bound = obj.getBoundingRect();
                if(Math.abs(bound.left - _bound.left) < 1)  position.vl.left = _bound.left;
                if(Math.abs(bound.left + bound.width - _bound.left) < 1) position.vr.left = _bound.left;
                if(Math.abs(bound.left - _bound.left - _bound.width) < 1)  position.vl.left = _bound.left + _bound.width;
                if(Math.abs(bound.top - _bound.top) < 1)  position.ht.top = _bound.top;
                if(Math.abs(bound.top + bound.height - _bound.top) < 1) position.ht.top = _bound.top;
                if(Math.abs(bound.top - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
                if(Math.abs(bound.left + bound.width - _bound.left - _bound.width) < 1)  position.vr.left = _bound.left + _bound.width;
                if(Math.abs(bound.top + bound.height - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
                if(Math.abs(bound.left + bound.width / 2 - _bound.left - _bound.width / 2) < 1) position.vc.left = _bound.left + _bound.width / 2;
                if(Math.abs(bound.top + bound.height / 2 - _bound.top - _bound.height / 2) < 1) position.hc.top = _bound.top + _bound.height / 2;  
            });
            if(Math.abs(bound.left + bound.width / 2 - _canvas.width / 2) < 1)  position.vcc.left = _canvas.width / 2;
            if(Math.abs(bound.top + bound.height / 2 - _canvas.height / 2) < 1)  position.hcc.top = _canvas.height / 2;
            
            if(Math.abs(bound.left) < 1)  position.vel.left = 0;
            if(Math.abs(bound.top) < 1)  position.het.top = 0;
            if(Math.abs(bound.left + bound.width - _canvas.width) < 1)  position.ver.left = _canvas.width;
            if(Math.abs(bound.top + bound.height - _canvas.height) < 1)  position.heb.top = _canvas.height;
            
            angular.merge($scope.stages[$scope.currentStage].states.snaplines, position);
        }
    };    
    $scope.onObjectModified = function(id, options){
        var item = options.target;    		
        if( $scope.stages[$scope.currentStage].tempParameters ){
            $scope.setHistory({
                element: item,
                parameters: $scope.stages[$scope.currentStage].tempParameters,
                interaction: 'modify'
            });
            $scope.stages[$scope.currentStage].tempParameters = null;
        }
    };    
    $scope.onBeforeRender = function(id, options){
        
    };      
    $scope.onAfterRender = function(id, options){
        
    };    
    $scope.onSelectionCleared = function(id, options){
        $scope.stages[$scope.currentStage].states.isActiveLayer = false;
        $scope.stages[$scope.currentStage].states.itemId = null;
        $scope.stages[$scope.currentStage].states.isEditing = false;
    };     
    $scope.onEditingEntered = function(id, options){
        $scope.stages[$scope.currentStage].states.isEditing = true;
        $scope.updateApp();
    };    
    $scope.onSelectionChanged = function(id, options){
        $scope.getCurrentLayerInfo();
    }; 
    $scope.onSelectionUpdated = function(id, options){
        $scope.getCurrentLayerInfo();
    };    
    $scope.onSelectionCreated = function(id, options){
        $scope.getCurrentLayerInfo();
    };  
    $scope.getCurrentLayerInfo = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'],
        object = _canvas.getActiveObject(),
        objects = _canvas.getActiveObjects();
        
        $scope.stages[$scope.currentStage].states.isActiveLayer = true;
        $scope.stages[$scope.currentStage].states.isGroup = false;
        $scope.stages[$scope.currentStage].states.isLayer = false;
        $scope.stages[$scope.currentStage].states.isText = false;
        $scope.stages[$scope.currentStage].states.isImage = false;      
        $scope.stages[$scope.currentStage].states.isPath = false;      
        $scope.stages[$scope.currentStage].states.isShape = false;      
        $scope.stages[$scope.currentStage].states.isEditing = false; 
        
        
        if( objects.length > 1 ){
            $scope.stages[$scope.currentStage].states.isGroup = true;
        }else{
            $scope.stages[$scope.currentStage].states.isLayer = true;
            if( object ){
                $scope.stages[$scope.currentStage].states.itemId = object.get('itemId');
                angular.copy($scope.defaultStageStates.text, $scope.stages[$scope.currentStage].states.text);
                $scope.stages[$scope.currentStage].states.opacity = fabric.util.toFixed(object.get('opacity') * 100);
                $scope.stages[$scope.currentStage].states.type = object.type;
                switch(object.type) {
                    case 'i-text':
                    case 'text':
                    case 'curvedText':
                        $scope.stages[$scope.currentStage].states.isText = true;
                        $scope.stages[$scope.currentStage].states.isEditing = object.isEditing ? object.isEditing : false;
                        $scope.stages[$scope.currentStage].states.text = {
                            font: $scope.getFontInfo(object.get('fontFamily')),
                            fontFamily: object.get('fontFamily'),
                            fontSize: object.get('fontSize'),
                            textAlign: object.get('textAlign'),
                            fontWeight: object.get('fontWeight'),
                            textDecoration: object.get('textDecoration'),
                            fontStyle: object.get('fontStyle'),
                            is_uppercase: $scope.isUpperCase(object),
                            spacing: object.get('spacing'),
                            lineHeight: object.get('lineHeight'),
                            fill: object.get('fill')                         
                        };
                        break;
                    case 'image':
                    case 'custom-image':
                        $scope.stages[$scope.currentStage].states.isImage = true;
                        break;
                    case 'rect':
                    case 'triangle':
                    case 'line':
                    case 'polygon':                    
                    case 'circle':
                        $scope.stages[$scope.currentStage].states.isShape = true;
                        break;     
                    case 'path-group':                    
                    case 'path':
                    case 'group':
                        $scope.stages[$scope.currentStage].states.isPath = true;
                        $scope.stages[$scope.currentStage].states.svg.groupPath = $scope.getPathOfSvg(object);
                        break;                       
                    default:
                        //
                }
            }            
        }        
        $scope.updateApp();
    };
    /*
     * Check the text of a layer is uppercase 
     * @param fabric.canvas.item object
     * @returns {Boolean}
     */
    $scope.getFontInfo = function(alias){
        var font = _.filter($scope.resource.font.data, { alias: alias })[0],
            _font = angular.copy(font, _font);
        _font.file = {r: 1};
        _font.file.i = angular.isDefined(font.file.i) ? 1 : 0;
        _font.file.b = angular.isDefined(font.file.b) ? 1 : 0;
        _font.file.bi = angular.isDefined(font.file.bi) ? 1 : 0;
        return _font;
    };
    $scope.getPathOfSvg = function(object){
        var groupPath = [];
        _.each(object._objects, function(path, index){
            var color = tinycolor(path.get('fill')).toHexString();
            if(  ( findex = _.findIndex(groupPath, ['color', color]) ) > -1 ){
                groupPath[findex]['index'].push(index);
            }else{
                groupPath.push({color: color, index: [index]});
            }
        });
        return groupPath;
    };  
    $scope.isUpperCase = function( object ){
        var _isUpperCase = angular.isDefined(object.is_uppercase) ? object.is_uppercase : false;
        return _isUpperCase;
    };    
    /* History */
    $scope.itemToJson = function(item, params){
        if(params){
            return JSON.stringify(params);
        }else{
            return JSON.stringify(item);
        }
    };   
    $scope.setItemParameters = function(parameters, itemId){
        var params = JSON.parse(parameters),
            _canvas = this.stages[this.currentStage]['canvas'],    
            item = _canvas.item(this.getLayerById(itemId));
            if(typeof params.src !== "undefined"){
                fabric.Image.fromURL(params.src, function(op) {
                    item.getElement().setAttribute("src", params.src);  
                });
            } 
        item.set(params);  
        item.setCoords();
        /* In case image layer has filter */
        if( angular.isDefined(params.filters) ){
            _.each(params.filters, function(value, index){
                if(value != null){
                    //$scope.applyFilters(item, index, value, false);
                };
            });
            item.applyFilters(function() {
                _canvas.renderAll()
            });
        }        
    };
    $scope.undo = function(){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage['canvas']; 
        if( _stage.undos.length > 0 ){
            var last = _stage.undos.pop(),
                _parameters = last.parameters;    
            if(last.interaction === 'remove') {
                $scope.contextAddLayers = 'undo';
                _canvas.add(last.element);
                last.interaction = 'add';
            } else if(last.interaction === 'add') {
                var item = _canvas.item($scope.getLayerById(last.element.itemId));
                _canvas.remove(item);
                last.interaction = 'remove';
            } else {
                var item = _canvas.item($scope.getLayerById(last.element.itemId)),
                    parameters = JSON.parse(_parameters);
                _.each(parameters, function(val, key) {
                    parameters[key] = item.get(key);
                });
                _parameters = JSON.stringify(parameters);
                this.setItemParameters(last.parameters, last.element.itemId);  
            } 
            this.setHistory(false, {
                element: last.element,
                parameters: _parameters,
                interaction: last.interaction
            }); 
            $scope.deactiveAllLayer();
            this.renderStage();            
        }
        $scope.updateApp();
    };  
    $scope.redo = function(){
        var _stage = this.stages[this.currentStage],
            _canvas = _stage['canvas'];    
        if( _stage.redos.length > 0 ){
            var last = _stage.redos.pop(),
                _parameters = last.parameters;    
            if(last.interaction === 'remove') {
                $scope.contextAddLayers = 'redo';
                _canvas.add(last.element);
                last.interaction = 'add';
            } else if(last.interaction === 'add') {
                var item = _canvas.item($scope.getLayerById(last.element.itemId));
                _canvas.remove(item);
                last.interaction = 'remove';
            } else {
                var item = _canvas.item($scope.getLayerById(last.element.itemId)),
                    parameters = JSON.parse(_parameters);
                _.each(parameters, function(val, key) {
                    parameters[key] = item.get(key);
                });
                _parameters = JSON.stringify(parameters);
                this.setItemParameters(last.parameters, last.element.itemId);  
            } 
            this.setHistory({
                element: last.element,
                parameters: _parameters,
                interaction: last.interaction
            }); 
            $scope.deactiveAllLayer();
            this.renderStage();            
        };
        $scope.updateApp();
    };  
    $scope.setHistory = function(undo, redo){
        var _stage = this.stages[this.currentStage];
        if (undo) {
            if(angular.isUndefined(_stage.undos)) _stage.undos = [];
            _stage.undos.push(undo);
            if(_stage.undos.length > 50) _stage.undos.shift();
            _stage.states.isUndoable = true;
        }else{
            if(angular.isUndefined(_stage.redos)) _stage.redos = [];
            _stage.states.isRedoable = true;
            _stage.redos.push(redo);
        };
        $scope.updateApp();
        $scope.updateStatusHistory();
    };
    $scope.updateStatusHistory = function(){
        var _stage = this.stages[this.currentStage];
        _stage.states.isUndoable = (_stage.undos.length > 0) ? true : false; 
        _stage.states.isRedoable = (_stage.redos.length > 0) ? true : false;
        $scope.updateApp();
    }; 
    $scope.clearHistory = function(){
        var _stage = this.stages[this.currentStage];
        _stage.undos = [];
        _stage.redos = [];
        _stage.states.isRedoable = false;
        _stage.states.isUndoable = false;
        $scope.updateApp();
    };
    /* Design tools */
    $scope.currentStage = 0;
    $scope.debug = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        //$scope.addText();
        
//Add group        
//        var _canvas = this.stages[$scope.currentStage]['canvas'],
//        item1 = _canvas.item(0),
//        item2 = _canvas.item(1);
//var selection = new fabric.ActiveSelection([item1, item2], {
//  canvas: _canvas
//});
//_canvas.setActiveObject(selection);
//$scope.renderStage();
//
//var item3 = _canvas.item(2);
//var selection = _canvas.getActiveObject();
//if (selection.type === 'activeSelection') {
//  selection.addWithUpdate(item3)
//}
//$scope.renderStage();

//Shape design
//        var path = new fabric.Path("M0 0 H20 V20 H0z M 10 0 A 10 10, 0, 1, 0, 10 20 A 10 10, 0, 1, 0, 10 0z");
//        path.set({strokeWidth: 0});
//        _canvas.add(path);

//Add group
//var iText = new fabric.IText('Hello World!', {
//    left: 10,
//    top: 20,
//    fontFamily: 'Roboto',
//    fill: '#333'            
//});
//var circle = new fabric.Circle({
//  radius: 100,
//  fill: '#eef',
//  scaleY: 0.5
//});
//var group = new fabric.Group([ circle, iText ], {
//  left: 150,
//  top: 100,
//  angle: -10
//});      
//this.stages[this.currentStage]['canvas'].add(group);
        

//Copy layer to other stage
//$scope.tempLayer = _canvas.getActiveObject().toJSON($scope.includeExport);
//$scope.tempLayer = _canvas.getActiveObject().toJSON();
//console.log($scope.tempLayer);
        
//console.log($scope.tempLayer1);
//	_canvas.getActiveObject().clone(function(cloned) {
//            $scope.tempLayer = cloned;
//            console.log(typeof $scope.tempLayer);
//	}); 

//console.log(_canvas.getActiveObject().getBoundingRect());

//getScaledWidth
//console.log(_canvas.getActiveObject().getScaledWidth());
//console.log(_canvas.getActiveObject());


    };
    $scope.debug3 = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        var path = new fabric.Path("M0 0 H20 V20 H0z M 10 0 A 10 10, 0, 1, 0, 10 20 A 10 10, 0, 1, 0, 10 0z");
        path.set({strokeWidth: 0, scaleX: 15, scaleY: 15});
        _canvas.add(path);   
        $scope.renderStage();
    };
    $scope.tempLayer = {};
    $scope.tempLayer1 = {};
    $scope.debug2 = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        var item =  _canvas.getActiveObject();
        
        //console.log(item);
//        item.set({
//            top: 0,
//            left: 0,
//            scaleX: 5,
//            scaleY: 5
//        });
//        item.setCoords();
//        $scope.renderStage();
//        console.log(item);
        //item.set({'left': 0});
//        _canvas.viewportCenterObjectH(item);
//        item.setCoords();


// Copy object from json

//$scope.tempLayer = {
//  "type": "image",
//  "version": "2.3.0",
//  "originX": "left",
//  "originY": "top",
//  "left": 21,
//  "top": 55.5,
//  "width": 200,
//  "height": 203,
//  "fill": "#ff0000",
//  "stroke": null,
//  "strokeWidth": 0,
//  "strokeDashArray": null,
//  "strokeLineCap": "butt",
//  "strokeLineJoin": "miter",
//  "strokeMiterLimit": 10,
//  "scaleX": 1,
//  "scaleY": 1,
//  "angle": 0,
//  "flipX": false,
//  "flipY": false,
//  "opacity": 1,
//  "shadow": null,
//  "visible": true,
//  "clipTo": null,
//  "backgroundColor": "",
//  "fillRule": "nonzero",
//  "paintFirst": "fill",
//  "globalCompositeOperation": "source-over",
//  "transformMatrix": null,
//  "skewX": 0,
//  "skewY": 0,
//  "crossOrigin": "",
//  "cropX": 0,
//  "cropY": 0,
//  "src": "http://dev.cmsmart.net:3000/wp/wp-content/uploads/2018/05/134.jpg",
//  "filters": []
//};
//        var klass = fabric.util.getKlass($scope.tempLayer.type);
//        klass.fromObject($scope.tempLayer, function(item){
//            $scope.contextAddLayers = 'template';
//            _canvas.add(item);		
//        });
    
    console.log(_canvas.getActiveObject());
        $scope.renderStage();
        
    };
    $scope.renderStage = function( stage_id ){
        stage_id = stage_id ? stage_id :  $scope.currentStage;
        $scope.stages[stage_id]['canvas'].calcOffset();
        $scope.stages[stage_id]['canvas'].renderAll();
    };
    $scope.deactiveAllLayer = function(){
        $scope.stages[$scope.currentStage]['canvas'].discardActiveObject();
        $scope.renderStage();        
    };
    /* General */
    $scope.applyFilters = function(item, index, value, addintion){
        //do something
    };
    $scope.deleteLayers = function(){
        var _canvas = this.stages[$scope.currentStage]['canvas'];
        //if(item.isEditing) return;
        if(_canvas.getActiveObjects()){
            _canvas.getActiveObjects().forEach(function(o){
                $scope.setHistory({
                    element: o,
                    parameters: JSON.stringify(o.toJSON()),
                    interaction: 'remove'
                }); 
                _canvas.remove(o); 
            });
            _canvas.discardActiveObject().renderAll();
        } 
        return;
    };
    $scope.copyLayers = function(){
        var _canvas = this.stages[$scope.currentStage]['canvas'];
	_canvas.getActiveObject().clone(function(cloned) {
            _clipboard = cloned;
	}); 
        _clipboard.clone(function(clonedObj) {
            _canvas.discardActiveObject();
            clonedObj.set({
                left: clonedObj.left + 10,
                top: clonedObj.top + 10,
                evented: true
            });
            if (clonedObj.type === 'activeSelection') {
                clonedObj.canvas = _canvas;
                clonedObj.forEachObject(function(obj) {
                    $scope.contextAddLayers = 'copy';
                    _canvas.add(obj);
                });
                clonedObj.setCoords();
            } else {
                $scope.contextAddLayers = 'copy';
                _canvas.add(clonedObj);
            }
            _canvas.setActiveObject(clonedObj);
            _canvas.requestRenderAll();            
        });
    };  
    $scope.alignLayer = function(command){
        var _canvas = this.stages[this.currentStage].canvas,
            group = _canvas.getActiveObject(),   
            items = _canvas.getActiveObjects(),
            _bound = items[0].getBoundingRect(),    
            position = {
                left: _bound.left,
                top: _bound.top,
                right: _bound.left + _bound.width,
                bottom: _bound.top + _bound.height
            };  
        var _leftPosition = [],   
            _topPosition = [],   
            totalWidth = 0,
            totalHeight = 0;  

        items.forEach(function(item, index){
            var bound = item.getBoundingRect();
            if(bound.left < position.left) position.left = bound.left;
            if(bound.top < position.top) position.top = bound.top;
            if(bound.left + bound.width > position.right) position.right = bound.left + bound.width;
            if(bound.top + bound.height > position.bottom) position.bottom = bound.top + bound.height;
            _leftPosition.push({index: index, value: bound.left});
            _topPosition.push({index: index, value: bound.top});
            totalWidth += bound.width;
            totalHeight += bound.height;
        });
        switch(command) {
            case 'horizontal':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({top: item.get('top') + (position.top + position.bottom) / 2 - bound.top - bound.height / 2});
                    item.setCoords();                       
                });
                break;
            case 'vertical':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({left: item.get('left') + (position.left + position.right) / 2 - bound.left - bound.width / 2});
                    item.setCoords();
                });                    
                break;
            case 'top':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({top: item.get('top') + position.top - bound.top });
                    item.setCoords();
                });                    
                break;
            case 'bottom':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({top: item.get('top') + position.bottom - bound.top - bound.height });
                    item.setCoords();
                });                     
                break;  
            case 'left':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({left: item.get('left') - bound.left + position.left});
                    item.setCoords();
                });
                break;
            case 'right':
                items.forEach(function(item){
                    var bound = item.getBoundingRect();
                    item.set({left: item.get('left') - bound.left + position.right - bound.width});
                    item.setCoords();
                });                      
                break;
            case 'dis-horizontal':
                leftPosition = _.sortBy(_leftPosition, [function(o) { return o.value; }]);
                var space = (position.right - position.left - totalWidth) / (items.length - 1);
                leftPosition.forEach(function(_item, _index){
                    var index = _item.index;
                    if(_index > 0 && _index < items.length - 1){
                        var item = items[index],
                        previous_item = items[leftPosition[_index-1].index],
                        bound = item.getBoundingRect(),
                        previous_item_bound = previous_item.getBoundingRect();
                        item.set({'left': item.get('left') - bound.left +  previous_item_bound.left + previous_item_bound.width + space });
                        item.setCoords();                            
                    }
                });
                break;
            case 'dis-vertical':
                topPosition = _.sortBy(_topPosition, [function(o) { return o.value; }]);
                var space = (position.bottom - position.top - totalHeight) / (items.length - 1);
                topPosition.forEach(function(_item, _index){
                    var index = _item.index;
                    if(_index > 0 && _index < items.length - 1){
                        var item = items[index],
                        previous_item = items[topPosition[_index-1].index],
                        bound = item.getBoundingRect(),
                        previous_item_bound = previous_item.getBoundingRect();
                        item.set({'top': item.get('top') - bound.top + previous_item_bound.top + previous_item_bound.height + space });
                        item.setCoords();
                    }
                });
                break;                  
        };    
        group.addWithUpdate();
        this.renderStage();
    };    
    $scope.translateLayer = function(command){
        var stage = $scope.stages[$scope.currentStage],
            _canvas = stage.canvas,
            item = _canvas.getActiveObject(),
            bound = item.getBoundingRect(),
            left = item.get('left'),
            top = item.get('top');
        switch(command) {
            case 'horizontal':
                _canvas.viewportCenterObjectH(item);
                break;
            case 'vertical':
                _canvas.viewportCenterObjectV(item);
                break;
            case 'center':
                _canvas.viewportCenterObjectH(item);
                _canvas.viewportCenterObjectV(item);
                break;                
            case 'top':
                item.set({top: 0});
                break;
                break;                
            case 'top-left':
                item.set({top: 0, left: 0});
                break;   
            case 'top-center':
                _canvas.viewportCenterObjectH(item);
                item.set({top: 0});
                break; 
            case 'top-right':
                item.set({top: 0, left: left + _canvas.width - bound.width - bound.left});
                break;            
            case 'bottom':
                item.set({top: top + _canvas.height - bound.height - bound.top});
                break;  
            case 'bottom-left':
                item.set({left: 0, top: top + _canvas.height - bound.height - bound.top});
                break; 
            case 'bottom-center':
                _canvas.viewportCenterObjectH(item);
                item.set({top: top + _canvas.height - bound.height - bound.top});
                break;
            case 'bottom-right':
                item.set({left: left + _canvas.width - bound.width - bound.left, top: top + _canvas.height - bound.height - bound.top});
                break;             
            case 'left':
                item.set({left: 0});
                break;
            case 'middle-left':
                _canvas.viewportCenterObjectV(item);
                item.set({left: 0});
                break;                
            case 'right':
                item.set({left: left + _canvas.width - bound.width - bound.left});
                break;       
            case 'middle-right':
                _canvas.viewportCenterObjectV(item);
                item.set({left: left + _canvas.width - bound.width - bound.left});
                break;             
        };
        item.setCoords();
        $scope.renderStage();        
    };
    $scope.getLayerById = function(itemId){
        var _canvas = this.stages[this.currentStage].canvas;
        var _index;
        _canvas.forEachObject(function(obj, index) {
            if(obj.get('itemId') == itemId) _index = index;
        });
        return _index;
    };     
    $scope.closePopupClearStage = function(){
        jQuery('.clear-stage-alert .close-popup').triggerHandler('click');
    };
    $scope.clearStage = function(){
        this.stages[this.currentStage]['canvas'].clear();
        jQuery('.clear-stage-alert .close-popup').triggerHandler('click');
    };
    $scope.stageToJson = function(stage_id){
        stage_id = stage_id ? stage_id :  $scope.currentStage;
        $scope.renderStage(stage_id);
        var json = this.stages[stage_id]['canvas'].toJSON($scope.includeExport);
        return json;
    };
    $scope.loadStageFromJson = function(stage_id, json){
        var _canvas = this.stages[stage_id]['canvas'];
        _canvas.loadFromJSON(json, function() {  
            $scope.renderStage(stage_id);
        });
    };
    $scope.copyStage = function( stage_id ){
        stage_id = stage_id ? stage_id :  $scope.currentStage;
        $scope.tempStageDesign = {
            id: stage_id,
            design: $scope.stageToJson()
        };
    };
    $scope.pasteStage = function( dist_stage ){
        dist_stage = dist_stage ? dist_stage :  $scope.currentStage;
        $scope.loadStageFromJson(dist_stage, $scope.tempStageDesign.design);
        $scope.tempStageDesign = null;
    };
    $scope.clearClipboardDesign = function(){
        $scope.tempStageDesign = null;
    };    
    $scope.rotateLayer = function(command){
        var _canvas = this.stages[this.currentStage]['canvas'],
        item = _canvas.getActiveObject();
        $scope.beforeObjectModify(item);
        switch(command){
            case 'reflect-hoz':
                item.toggle("flipY");
                break;
            case 'reflect-ver':
                item.toggle("flipX");
                break;       
            case '90cw':
                var angle = item.getAngle() + 90
                if (angle > 360) angle = angle - 360;
                if (angle < 0) angle = angle + 360;
                item.setAngle(angle);
                break;
            case '90ccw':
                var angle = item.getAngle() - 90
                if (angle > 360) angle = angle - 360;
                if (angle < 0) angle = angle + 360;
                item.setAngle(angle);
                break;    
            case '180':
                var angle = item.getAngle() + 180
                if (angle > 360) angle = angle - 360;
                if (angle < 0) angle = angle + 360;
                item.setAngle(angle);
                break;      
            default: 
                var angle = parseInt(command);
                item.setAngle(angle);
        };   
        item.setCoords();
        this.renderStage();
    }; 
    $scope.moveLayer = function( command, alt ){
        var _canvas = this.stages[this.currentStage].canvas,
            items = _canvas.getActiveObjects(),
            selection = _canvas.getActiveObject(),
            step = alt ? 1 : 10;
        if( items.length == 0 ) return;    
        angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});
        items.forEach(function( item ){
            switch(command) {
                case 'up':
                    item.set('top', item.get('top') - step);
                    break;
                case 'down':
                    item.set('top', item.get('top') + step);
                    break;    
                case 'left':
                    item.set('left', item.get('left') - step);
                    break;
                case 'right':
                    item.set('left', item.get('left') + step);
                    break;               
            };  
            item.setCoords();
        });
        if( selection.type === 'activeSelection' ){
            selection.addWithUpdate();
        };
        this.updateApp();
        this.renderStage();
    };
    $scope.updateLayersList = function(){
        //todo with layer
    };    
    $scope.setStackLayerAlwaysOnTop = function(maybeRender){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        _canvas.forEachObject(function(obj) {
            if( obj.isAlwaysOnTop ){
                obj.bringToFront();
            }
        });
        if(maybeRender) $scope.renderStage();
    };
    $scope.setStackPosition = function(command){
        var item = $scope.stages[$scope.currentStage]['canvas'].getActiveObject();
        $scope.beforeObjectModify(item);
        switch(command){
            case 'bring-front':
                item.bringToFront();
                $scope.setStackLayerAlwaysOnTop();
                break;
            case 'bring-forward':
                item.bringForward();
                break;
            case 'send-backward':
                item.sendBackwards();
                break;
            case 'send-back':
                item.sendToBack();
                break;
            default:
                var index = parseInt(command);
                item.moveTo(index);   
        }
        $scope.renderStage();
    };  
    $scope.changeFill = function(color){
        var _stage = $scope.stages[$scope.currentStage],
            _canvas = _stage.canvas;
        if( angular.equals({}, _canvas) ) return;
        var item = _canvas.getActiveObject();
        $scope.beforeObjectModify(item);
        if( _stage.states.type != 'group' ){
            item.set({fill: color});
            _stage.states.text.fill = color;
        }else{
            item.set({dirty: true});
            _.each(_stage.states.svg.groupPath[_stage.states.svg.currentPath].index, function(path_index){
                item._objects[path_index].set({fill: color});
            });
            _stage.states.svg.groupPath[_stage.states.svg.currentPath].color = color;
        }
        $scope.renderStage();
    };
    
    $scope.showTextColorPalette = function(){
        $scope.showTextColorPicker = !$scope.showTextColorPicker;
    };
    /* Text */
    $scope.addText = function(){
        $scope.stages[$scope.currentStage]['canvas'].add(new FabricWindow.IText($scope.settings.nbdesigner_default_text, {
            fontFamily: "Roboto",
            radius: 50,
            fontSize: 36,
            noScaleCache: false,
            spacing: 0
        }));
    };
    $scope.setLayerAttribute = function(type, value){
         var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        var item = _canvas.getActiveObject();
        $scope.beforeObjectModify(item);
        item.set({type: value});
        $scope.renderStage();
        $scope.stages[$scope.currentStage].states.text[type] = value;        
    };
    $scope.setTextAttribute = function(type, value, extra_option){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        var item = _canvas.getActiveObject();
        $scope.beforeObjectModify(item);
        item.set({[type]: value});
        switch(type){
            case 'is_uppercase':
                value ? item.set({'text': item.get('text').toUpperCase()}) : item.set({'text': item.get('text').toLowerCase()});
                break;
            case 'fontFamily':
                if(!_.filter($scope.stages[$scope.currentStage].states.fontUsed, ['alias', value]).length){
                    $scope.stages[$scope.currentStage].states.fontUsed.push($scope.getFontInfo(value));
                }
                $scope.stages[$scope.currentStage].states.text.font = $scope.getFontInfo(value);
                if( !$scope.stages[$scope.currentStage].states.text.font.file.b ) {
                    item.set({fontWeight: 'normal'});
                    $scope.stages[$scope.currentStage].states.text.fontWeight = 'normal';
                };
                if( !$scope.stages[$scope.currentStage].states.text.font.file.i ) {
                    item.set({fontStyle: 'normal'});
                    $scope.stages[$scope.currentStage].states.text.fontStyle = 'normal';
                };
                if( !$scope.stages[$scope.currentStage].states.text.font.file.bi && item.get('fontWeight') == 'bold' && item.get('fontStyle') == 'italic' ) {
                    item.set({fontWeight: 'normal', fontStyle: 'normal'});
                    $scope.stages[$scope.currentStage].states.text.fontWeight = 'normal';
                    $scope.stages[$scope.currentStage].states.text.fontStyle = 'normal';
                };        
                break;
        }
        $scope.renderStage();
        $scope.stages[$scope.currentStage].states.text[type] = value;
    };    
    /* Image */
    $scope.replaceImage = function(){
        //todo
    };
    $scope.addImage = function(url){
        if(angular.isUndefined(url)) url = 'http://dev.cmsmart.net:3000/wp/wp-content/plugins/web-to-print-online-designer/data/typography/img/23.png';
        fabric.Image.fromURL(url, function(op) {
            op.set({fill: '#ff0000'});
            $scope.stages[$scope.currentStage]['canvas'].add(op);
        });        
    };
    /* SVG */
    $scope.addArt = function(art){
        if(art.url.match(/\.(jpeg|jpg|gif|png)$/) != null){
            $scope.addImage(art.url);
        }else{
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            fabric.loadSVGFromURL(art.url, function(ob, op) {
                var max_width = _canvas.width * .9;
                var max_height = _canvas.height * .9;
                var new_width = max_width;
                if (op.width < max_width) new_width = op.width;
                var width_ratio = new_width / op.width;
                var new_height = op.height * width_ratio;
                if (new_height > max_height) {
                    new_height = max_height;
                    var height_ratio = new_height / op.height;
                    new_width = op.width * height_ratio
                }
                _canvas.add((fabric.util.groupSVGElements(ob, op)).set({
                    left: 100,
                    top: 100,
                    svg_name: art.name,
                    scaleX: new_width / op.width,
                    scaleY: new_height / op.height                    
                }));
            })            
        }
    };
    $scope.init();
}]);
nbdApp.factory('FabricWindow', ['$window', function($window) {
    /* Fabric configuration */
    $window.fabric.Object.prototype.set({ 
//        centeredScaling: true,
        transparentCorners: false,
        borderColor: 'rgba(79, 84, 103,0.7)',
        cornerStyle: 'circle',
        cornerColor: 'rgba(255,255,255,1)',
        borderDashArray:[2,2],
        cornerStrokeColor: 'rgba(63, 70, 82,1)',
        fill : '#272c33', 
        borderOpacityWhenMoving: 0
    });
    if( checkMobileDevice() ) $window.fabric.Object.prototype.set({cornerSize: 17});
    $window.fabric.IText.prototype.set({
        cursorWidth: 1,
        cursorColor: '#000',
        selectionColor: "rgba(19, 147, 255, 0.3)",
        cursorDuration: 500    
    });
    $window.fabric.Canvas.prototype.set({
        preserveObjectStacking : true,
        selectionColor: 'rgba(100, 100, 255, 0.5)'
    });        
    return $window.fabric;
}]);
nbdApp.directive('nbdCanvas', ['FabricWindow', '$timeout', '$rootScope', function(FabricWindow, $timeout, $rootScope){
    return {
        restrict: "AE",
        scope: {
            stage: '=stage',
            index: '@'
        },
        link: function( scope, element, attrs ) {
            $timeout(function() {
                scope.stage.canvas = new FabricWindow.Canvas('nbd-stage-'+scope.index);
                scope.$emit('canvas:created', scope.index);
                element.parent().children().on("contextmenu", function(e){
                    e.preventDefault();
                    scope.$emit('nbd:contextmenu', e);
                });
            });          
        }
    }
}]);
nbdApp.directive('keypress', ['$window', function($window){
    return {
        restrict: "AE",
        link: function( scope, element, attrs ) {
            $window.document.addEventListener("keydown", function(e){
                scope.$emit('nbd:keypress', e);
            }, false);           
        }
    }
}]);
nbdApp.directive('nbdScroll', ['$timeout', function($timeout){
    return {
        restrict: "AE",
        scope: {
            container: '@',
            type: '@',
            offset: '@',
            action: '&nbdScroll'
        },
        link: function( scope, element, attrs ) {
            $timeout(function() {
                var el = scope.type != 'font' ? jQuery(scope.container + ' .tab-scroll') : jQuery(scope.container),
                    offset = parseInt(scope.offset),
                    elInfo = jQuery(scope.container + ' .info-support');
                el.on('ps-scroll-y', function(){
                    if(el.prop("clientHeight") != el.prop("scrollHeight") && ((el.prop("scrollTop") + el.prop("clientHeight") - el.prop("scrollHeight") + offset) > 0) ){
                        scope.action({container: scope.container, type: scope.type});
                    };
                    if( elInfo.length ){
                        el.prop("scrollTop") > 1500 && elInfo.addClass('slideInDown animated show') || elInfo.removeClass('slideInDown animated show');
                    }
                });
            });
        }
    }
}]);
nbdApp.directive('endRepeatColorPicker', ['$timeout', function($timeout){
    return {
        restrict: "A",
        link: function( scope, element, attrs ) {
            $timeout(function() {
                jQuery(element).nbdColorPalette();
            });
        }
    }    
}]);
nbdApp.directive('repeatEnd', [ function(){
    return {
        restrict: "AE",    
        link: function( scope, element, attrs ) {  
            if(scope.$last) {
                scope.$eval(attrs.repeatEnd);
            }            
        }
    }
}]);
nbdApp.directive('keyup', ['$window', function($window){
    return {
        restrict: "AE",
        link: function( scope, element, attrs ) {
            $window.document.addEventListener("keyup", function(e){
                scope.$emit('nbd:keyup', e);
            }, false);           
        }
    }
}]);
nbdApp.filter('keyboardShortcut', function($window) {
    return function(str) {
        if (!str)
            return;
        var keys = str.split('-');
        var isOSX = /Mac OS X/.test($window.navigator.userAgent);
        var seperator = (!isOSX || keys.length > 2) ? '+' : '';
        var abbreviations = {
            M: isOSX ? '' : 'Ctrl',
            A: isOSX ? 'Option' : 'Alt',
            S: 'Shift'
        };
        return keys.map(function (key, index) {
            var last = index == keys.length - 1;
            return last ? key : abbreviations[key];
        }).join(seperator);
    };    
});
nbdApp.filter("filterFont", function() {
    return function(fonts, filterFont) {
        var arrFont = [];
        angular.forEach(fonts, function(font, key) {
            var check = [];
            check['limit'] = arrFont.length > ( filterFont.perPage * filterFont.currentPage  - 1 ) ? false : true;
            if( !!filterFont.search ){
               check['name'] = font.name.toLowerCase().indexOf(filterFont.search.toLowerCase()) >= 0 ? true : false;
            }else{
                check['name'] = true;
            };
            if( check['limit'] && check['name'] )arrFont.push(font);
        });
        arrFont = _.sortBy(arrFont, [function(o) { return o.name; }]);
        return arrFont
    }
});
nbdApp.filter("filterArt", function() {
    return function(arts, filterArt) {
        var arrArt = [];
        arts = _.sortBy(arts, [function(o) { return o.name; }]);
        angular.forEach(arts, function(art, key) {
            var check = [];
            check['limit'] = arrArt.length > ( filterArt.perPage * filterArt.currentPage  - 1 ) ? false : true;
            if( !!filterArt.search ){
               check['name'] = art.name.toLowerCase().indexOf(filterArt.search.toLowerCase()) >= 0 ? true : false;
            }else{
                check['name'] = true;
            };
            if( !!filterArt.currentCat.id ){
                check['cat'] = _.includes(art.cat, filterArt.currentCat.id) ? true : false;
            }else{
                check['cat'] = true;
            }
            if( check['limit'] && check['name'] && check['cat'] ) arrArt.push(art);
        });
        return arrArt
    }
});
nbdApp.directive("fontOnLoad", [ function() {
    return {
        restrict: "A",
        scope: {
            font: '=',
            preview: '=',
            loadFontFailAction: '&'
        },
        link: function(scope, element) {
            var fontName = scope.font.alias,
                fontType = scope.font.type;
            var font_id = fontName.replace(/\s/gi, '').toLowerCase();
            if( !jQuery('#' + font_id).length ){
                if(fontType == 'google'){
                    jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family='+ fontName.replace(/\s/gi, '+') +'" rel="stylesheet" type="text/css">');
                }else{
                    var font_url = scope.font.url;
                    if(! (scope.font.url.indexOf("http") > -1)) font_url = NBDESIGNCONFIG['font_url'] + scope.font.url; 
                    if (fontType == "ttf") type = "truetype";
                    var css = "";
                    css = "<style type='text/css' id='" + font_id + "' >";
                    css += "@font-face {font-family: '" + fontName + "';";
                    css += "src: local('\u263a'),";
                    css += "url('" + font_url + "') format('" + type + "')";
                    css += "}";
                    css += "</style>";
                    jQuery("head").append(css);
                }
            };
            var font = new FontFaceObserver(fontName);             
            font.load(scope.preview).then(function () {
                element.removeClass('font-loading');
            }, function () {
                scope.loadFontFailAction({font: scope.font});
            }); 
            element.addClass('font-loading');
        }
    }
}]);
nbdApp.factory('NBDDataFactory', function($http){
    return {
        get : function(action, data, callback) {
            var formData = new FormData();
            formData.append("action", action);
            var nonce = action == 'nbd_get_resource' ? NBDESIGNCONFIG['nonce_get'] : NBDESIGNCONFIG['nonce'];
            formData.append("nonce", nonce);
            angular.forEach(data, function (value, key) {
                formData.append(key, value);
            });
            var config = {
                transformRequest: angular.identity,
                transformResponse: angular.identity,
                headers: {
                    'Content-Type': undefined
                }
            };
            var url = NBDESIGNCONFIG['ajax_url'];
            $http.post(url, formData, config).then(
                function(response) {
                    callback(response.data);
                },
                function(response) {
                    console.log(response);
                }
            );           
        }
    }
});