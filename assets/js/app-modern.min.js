/* nbdesignerjs
 * @author  netbaseteam
 * @link https://cmsmart.net
 * @version 1.9.0
 * @created Jun 2016
 * @modified 23, May 2018
 * */
var nbdApp = angular.module('nbd-app', ["angularSpectrumColorpicker"]);
nbdApp.controller('designCtrl', ['$scope', 'FabricWindow',function($scope, FabricWindow){
    $scope.stages = [
        {
            config: {
                width: checkMobileDevice() ? 200: 410,
                height: checkMobileDevice() ? 200: 410,
                background: '#fff'
            },
            states: {},
            canvas: {}
        },       
        {
            config: {
                width: checkMobileDevice() ? 200: 410,
                height: checkMobileDevice() ? 200: 410,
                background: '#404762'
            },
            states: {},
            canvas: {}
        }      
    ];
    $scope.defaultStageStates = {
        isActiveLayer: false,
        isLayer: false,
        isGroup: false,
        isText: false,
        isImage: false,
        boundingObject: {},
        coordinates: {},
        rotate: {},
        snaplines: {},
        itemId: null,
        text: {
            fontFamily: {
                alias: 'Roboto',
                r: 1,
                b: 1,
                i: 1,
                bi: 1
            },
            fontSize: 14,
            align: 'left',
            fontWeight: false,
            textDecoration: false,
            is_uppercase: false,
            fill: '#06d79c'
        }
    };
    $scope.colorBackground = '#169ddf';
    $scope.changeBackgroundColor = function(color){
        console.log(color);
    };
    $scope.initSettings = function(){
        angular.copy(NBDESIGNCONFIG, $scope.settings);
        angular.extend($scope.settings, {
            showRule: true,
            showGrid: true,
            snapMode: true,
        });
        $scope.__colorPalette = __colorPalette;
    };
    $scope.settings = {};
    $scope.isModern = true;
    $scope.init = function() {
        $scope.initSettings();
        $scope.calcViewport();
    };
    $scope.updateApp = function(){
        if ($scope.$root.$$phase !== "$apply" && $scope.$root.$$phase !== "$digest") $scope.$apply(); 
    };
    $scope.$on('nbd:keypress', function(event, e){
        $scope.keypressHandle(e);
    });
    $scope.keypressHandle = function(e){
        if((e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            console.log(e.which);
            
        }
    };  
    $scope.onClickStage = function( $event ){
        if(angular.element($event.target).hasClass('stage')){
            $scope.deactiveAllLayer();
        }
        $scope.ctxMenuStyle.display = 'none';
        $scope.updateApp();
    };    
    $scope.$on('nbd:contextmenu', function(event, e){
        $scope.contextMenu(e);
    });
    $scope.ctxMenuStyle = {
        'top': '17%',
        'left': '33%',
        'display': 'none'
    };
    $scope.contextMenu = function(e){
        e.preventDefault();
        if($scope.stages[$scope.currentStage].states.isActiveLayer){
            var posX = e.pageX,
                posY = e.pageY;
            $scope.ctxMenuStyle.top = posY;
            $scope.ctxMenuStyle.left = posX;
            $scope.ctxMenuStyle.display = 'block';
        }else{
            $scope.ctxMenuStyle.display = 'none';
        }
        $scope.updateApp();
    }; 
    $scope.$on('canvas:created', function(event, id){
        $scope.initStageSetting( id );
        var _canvas = $scope.stages[id].canvas;
        
        _canvas.selectionColor = "rgba(1, 196, 204, 0.3)";
        _canvas.selectionBorderColor= "#01c4cc";
        _canvas.selectionLineWidth= 0.5;
        
        _canvas.on('mouse:down', function(options) {
            $scope.onMouseDown(id, options);
        });
        _canvas.on("mouse:over", function(options){
            $scope.onMouseOverStage(id, options);
        });
        _canvas.on("mouse:out", function(options){
            $scope.onMouseOutStage(id, options);
        });
        _canvas.on("mouse:move", function(options){
            $scope.onMouseMoveStage(id, options);
        });        
        _canvas.on("mouse:up", function(options){
            $scope.onMouseUpStage(id, options);
        });
        _canvas.on("path:created", function(options){
            $scope.onPathCreated(id, options);
        });
        _canvas.on("object:added", function(options){
            $scope.onObjectAdded(id, options);
        });
        _canvas.on("selection:created", function(options){
            $scope.onSelectionCreated(id, options);
        });
        _canvas.on("object:scaling", function(options){
            $scope.onObjectScaling(id, options);
        });
        _canvas.on("object:moving", function(options){
            $scope.onObjectMoving(id, options);
        });
        _canvas.on("object:rotating", function(options){
            $scope.onObjectRotating(id, options);
        });
        _canvas.on("object:modified", function(options){
            $scope.onObjectModified(id, options);
        });
        _canvas.on("before:render", function(options){
            $scope.onBeforeRender(id, options);
        });
        _canvas.on("after:render", function(options){
            $scope.onAfterRender(id, options);
        });
        _canvas.on("selection:cleared", function(options){
            $scope.onSelectionCleared(id, options);
        });
        _canvas.on("text:editing:entered", function(options){
            $scope.onEditingEntered(id, options);
        });   
        _canvas.on("selection:updated", function(options){
            $scope.onSelectionUpdated(id, options);
        });        
        _canvas.on("text:selection:changed", function(options){
            $scope.onSelectionChanged(id, options);
        });
    });  
    $scope.calcViewport = function(){
        //console.log(jQuery('.nbd-stages').width() +'--'+ jQuery('.nbd-stages').height());
    };
    $scope.initStageSetting = function( id ){
        var _canvas = $scope.stages[id]['canvas'];
        $scope.setStageDimension(id);
        angular.copy($scope.defaultStageStates, $scope.stages[id].states);
        _canvas.controlsAboveOverlay = true;
        _canvas.calcOffset().renderAll();
    };
    $scope.addStage = function(){
        $scope.stages.push({canvas: {}});
    }; 
    $scope.setStageDimension = function(id){
        var currentWidth = $scope.stages[id].config.width,
            currentHeight = $scope.stages[id].config.width;
        $scope.stages[id]['canvas'].setDimensions({'width' : currentWidth, 'height' : currentHeight});
    };     
    $scope.switchStage = function(id, command){
        var idCurrentStage = 'stage-container-' + id,
            next =  parseInt(id) + 1;   
        if(command == 'prev')  {
            next  = parseInt(id) - 1;
        }
        if($scope.isModern){
            var idNextStage = 'stage-container-' + next;
            var currentStage = angular.element(document.getElementById(idCurrentStage)),
                nextStage = angular.element(document.getElementById(idNextStage));
            currentStage.addClass('animated');    
            currentStage.removeClass('fadeInUp');
            currentStage.removeClass('fadeInDown');  
            nextStage.addClass('animated');
            nextStage.removeClass('hidden');            
            nextStage.removeClass('fadeOutDown');            
            nextStage.removeClass('fadeOutUp');            
            if(command == 'prev'){
                currentStage.removeClass('fadeOutDown');
                currentStage.addClass('fadeOutUp');    
                nextStage.addClass('fadeInDown');                 
            }else {
                currentStage.removeClass('fadeOutUp');
                currentStage.addClass('fadeOutDown');    
                nextStage.addClass('fadeInUp');                 
            }; 
        }
        $scope.currentStage = next;
    };
    $scope.onMouseDown = function(id, options){    
        //angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'}); 
        $scope.updateApp();
    };
    $scope.onMouseOverStage = function(id, options){
        var _canvas = this.stages[$scope.currentStage]['canvas'],
        item = options.target;
        $scope.updateBoundingRect(item);
        $scope.updateApp();
    };   
    $scope.onMouseOutStage = function(id, options){
        if(options.target){  
            angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'}); 
        }       
        $scope.updateApp();
    }; 
    $scope.onMouseMoveStage = function(id, options){

        
    };   
    $scope.onMouseUpStage = function(id, options){
        angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});
        angular.merge($scope.stages[$scope.currentStage].states.coordinates, {style: {visibility: 'hidden'}}); 
        var position = {
            ht: {top: -9999},
            hb: {top: -9999},
            hc: {top: -9999},
            vl: {left: -9999},
            vr: {left: -9999},
            vc: {left: -9999},
            hcc: {top: -9999},
            vcc: {left: -9999},
            vel: {left: -9999},
            ver: {left: -9999},
            het: {top: -9999},
            heb: {top: -9999}
        };        
        angular.merge($scope.stages[$scope.currentStage].states.snaplines, position);
        angular.merge($scope.stages[$scope.currentStage].states.rotate, {style: {visibility: 'hidden'}});
        $scope.updateApp(); 
    };  
    $scope.onPathCreated = function(id, options){
        
    };   
    $scope.onObjectAdded = function(id, options){
        var _canvas = this.stages[$scope.currentStage]['canvas'],
        item = options.target,   
        d = new Date(),
        itemId = d.getTime();          
        item.set({"itemId" : itemId});
        _canvas.viewportCenterObject(item);
        item.setCoords();
        var top = item.get('top');
        item.set({top: top - 50});
        item.animate('top', top, {
            duration: 400,
            onChange: function(){
                $scope.renderStage();
            },
            onComplete: function(){
                //if(index == 0){
                    _canvas.setActiveObject(item); 
                //};
                $scope.renderStage();       
            },
            easing: FabricWindow.util.ease['easeInQuad']
        });   
        $scope.stages[$scope.currentStage].states.isActiveLayer = true;
        //$scope.updateApp();
    };  
    $scope.onObjectScaling = function(id, options){
        var item = options.target; 
        if(item) item.setCoords();
        $scope.updateCoordenatesLabel(item);
        $scope.updateBoundingRect(item);
        $scope.updateSnapLines();
        $scope.updateApp();
    };    
    $scope.onObjectMoving = function(id, options){
        var item = options.target; 
        if(item) item.setCoords();
        $scope.updateCoordenatesLabel(item);
        $scope.updateBoundingRect(item);
        $scope.updateSnapLines();
        $scope.updateApp();  
    }; 
    $scope.onObjectRotating = function(id, options){
        var item = options.target;
        if(item) item.setCoords();
        $scope.updateCoordenatesLabel(item);
        $scope.updateBoundingRect(item);
        $scope.updateSnapLines();
        $scope.updateAngleLabel(item);
        $scope.updateApp();         
    };   
    $scope.updateAngleLabel = function( item ){
        if(item){
            angular.merge($scope.stages[$scope.currentStage].states.rotate, {
                style: {
                    transform: "rotate("+item.angle+"deg)",
                    top: item.oCoords.mtr.y,
                    left: item.oCoords.mtr.x,
                    visibility: 'visible'                    
                },
                angle: fabric.util.toFixed(item.angle, 0)
            });
        }else{
            angular.merge($scope.stages[$scope.currentStage].states.rotate, {style: {visibility: 'hidden'}});   
        }
    };
    $scope.updateCoordenatesLabel = function(item){
        if(item){
            var bound = item.getBoundingRect();
            var top = item.oCoords.tl.y,
                left = item.oCoords.tl.x;
            if( (item.angle > 315 && item.angle < 360) || (item.angle > 45 && item.angle < 90) 
                    || (item.angle > 135 && item.angle < 180) || (item.angle > 225 && item.angle < 270) ){
                if( item.oCoords.tr.x < left ){
                    top = item.oCoords.tr.y;
                    left = item.oCoords.tr.x;
                }
                if( item.oCoords.br.x < left ){
                    top = item.oCoords.br.y;
                    left = item.oCoords.br.x;
                }   
                if( item.oCoords.bl.x < left ){
                    top = item.oCoords.bl.y;
                    left = item.oCoords.bl.x;
                }            
            }else{
                if( item.oCoords.tr.y < top ){
                    top = item.oCoords.tr.y;
                    left = item.oCoords.tr.x;
                }
                if( item.oCoords.br.y < top ){
                    top = item.oCoords.br.y;
                    left = item.oCoords.br.x;
                }   
                if( item.oCoords.bl.y < top ){
                    top = item.oCoords.bl.y;
                    left = item.oCoords.bl.x;
                }
            }
            angular.merge($scope.stages[$scope.currentStage].states.coordinates, {      
                style: {
                    visibility: 'visible',
                    top: top,
                    left: left                        
                },
                //todo something to recalculate real top, left
                top: parseInt(top),
                left: parseInt(left)
            });  
        }
    };
    $scope.updateBoundingRect = function(item){
        if(item){
            //if( $scope.stages[$scope.currentStage].states.itemId != item.get('itemId') ){
                var bound = item.getBoundingRect();
                angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {
                    visibility: 'visible',
                    top: item.oCoords.tl.y,
                    left: item.oCoords.tl.x,
                    width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2 )),
                    height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2 )),
                    transform: "rotate("+item.angle+"deg)"
                });               
            //}
        }else{
            angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});   
            angular.merge($scope.stages[$scope.currentStage].states.coordinates, {visibility: 'hidden'});   
        }
    };
    $scope.updateSnapLines = function(){
        var _canvas = this.stages[$scope.currentStage]['canvas'],
            item = _canvas.getActiveObject(),
            position = {
                ht: {top: -9999},
                hb: {top: -9999},
                hc: {top: -9999},
                vl: {left: -9999},
                vr: {left: -9999},
                vc: {left: -9999},
                hcc: {top: -9999},
                vcc: {left: -9999},
                vel: {left: -9999},
                ver: {left: -9999},
                het: {top: -9999},
                heb: {top: -9999}                
            };
        if( item ){
            var bound = item.getBoundingRect();
            _canvas.forEachObject(function(obj) {
                if( obj === item ) return;
                var _bound = obj.getBoundingRect();
                if(Math.abs(bound.left - _bound.left) < 1)  position.vl.left = _bound.left;
                if(Math.abs(bound.left + bound.width - _bound.left) < 1) position.vr.left = _bound.left;
                if(Math.abs(bound.left - _bound.left - _bound.width) < 1)  position.vl.left = _bound.left + _bound.width;
                if(Math.abs(bound.top - _bound.top) < 1)  position.ht.top = _bound.top;
                if(Math.abs(bound.top + bound.height - _bound.top) < 1) position.ht.top = _bound.top;
                if(Math.abs(bound.top - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
                if(Math.abs(bound.left + bound.width - _bound.left - _bound.width) < 1)  position.vr.left = _bound.left + _bound.width;
                if(Math.abs(bound.top + bound.height - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
                if(Math.abs(bound.left + bound.width / 2 - _bound.left - _bound.width / 2) < 1) position.vc.left = _bound.left + _bound.width / 2;
                if(Math.abs(bound.top + bound.height / 2 - _bound.top - _bound.height / 2) < 1) position.hc.top = _bound.top + _bound.height / 2;  
            });
            if(Math.abs(bound.left + bound.width / 2 - _canvas.width / 2) < 1)  position.vcc.left = _canvas.width / 2;
            if(Math.abs(bound.top + bound.height / 2 - _canvas.height / 2) < 1)  position.hcc.top = _canvas.height / 2;
            
            if(Math.abs(bound.left) < 1)  position.vel.left = 0;
            if(Math.abs(bound.top) < 1)  position.het.top = 0;
            if(Math.abs(bound.left + bound.width - _canvas.width) < 1)  position.ver.left = _canvas.width;
            if(Math.abs(bound.top + bound.height - _canvas.height) < 1)  position.heb.top = _canvas.height;
            
            angular.merge($scope.stages[$scope.currentStage].states.snaplines, position);
        }
    };    
    $scope.onObjectModified = function(id, options){
        var item = options.target;    		

    };    
    $scope.onBeforeRender = function(id, options){
        
    };      
    $scope.onAfterRender = function(id, options){
        
    };    
    $scope.onSelectionCleared = function(id, options){
        $scope. stages[$scope.currentStage].states.isActiveLayer = false;
        $scope. stages[$scope.currentStage].states.itemId = null;
    };     
    $scope.onEditingEntered = function(id, options){
        
    };    
    $scope.onSelectionChanged = function(id, options){
        $scope.getCurrentLayerInfo();
    }; 
    $scope.onSelectionUpdated = function(id, options){
        $scope.getCurrentLayerInfo();
    };    
    $scope.onSelectionCreated = function(id, options){
        $scope.getCurrentLayerInfo();
    };  
    $scope.getCurrentLayerInfo = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'],
        object = _canvas.getActiveObject(),
        objects = _canvas.getActiveObjects();
        
        $scope.stages[$scope.currentStage].states.isActiveLayer = true;
        $scope.stages[$scope.currentStage].states.isGroup = false;
        $scope.stages[$scope.currentStage].states.isLayer = false;
        $scope.stages[$scope.currentStage].states.isText = false;
        $scope.stages[$scope.currentStage].states.isImage = false;      
        
        if( objects.length > 1 ){
            $scope.stages[$scope.currentStage].states.isGroup = true;
        }else{
            $scope.stages[$scope.currentStage].states.isLayer = true;
            if( object ){
                $scope.stages[$scope.currentStage].states.itemId = object.get('itemId');
                angular.copy($scope.defaultStageStates.text, $scope.stages[$scope.currentStage].states.text);
                switch(object.type) {
                    case 'i-text':
                    case 'text':
                    case 'curvedText':
                        $scope.stages[$scope.currentStage].states.isText = true;
                        $scope.stages[$scope.currentStage].states.text = {
                            fontFamily: {
                                alias: 'Roboto',
                                r: 1,
                                b: 1,
                                i: 1,
                                bi: 1
                            },
                            fontSize: 14,
                            align: 'left',
                            fontWeight: object.get('fontWeight'),
                            textDecoration: object.get('textDecoration'),
                            is_uppercase: $scope.isUpperCase(object),
                            fill: object.get('fill')                         
                        };
                        break;
                    case 'image':
                        $scope.stages[$scope.currentStage].states.isImage = true;
                        break;
                    default:
                        //
                }
            }            
        }        
        $scope.updateApp();
    };
    $scope.isUpperCase = function( object ){
        var _isUpperCase = angular.isDefined(object.is_uppercase) ? object.is_uppercase : false;
        return _isUpperCase;
    };    
    /* History */
    $scope.isRedoable = false;
    $scope.isUndoable = false;    
    
    /* Design tools */
    $scope.currentStage = 0;
    $scope.defaultText = 'Tiếng Việt';
    $scope.debug = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        //$scope.addText();
        
//        var _canvas = this.stages[$scope.currentStage]['canvas'],
//        item1 = _canvas.item(0),
//        item2 = _canvas.item(1);
//var selection = new fabric.ActiveSelection([item1, item2], {
//  canvas: _canvas
//});
//_canvas.setActiveObject(selection);
//$scope.renderStage();
//
//var item3 = _canvas.item(2);
//var selection = _canvas.getActiveObject();
//if (selection.type === 'activeSelection') {
//  selection.addWithUpdate(item3)
//}
//$scope.renderStage();

        var path = new fabric.Path("M0 0 H20 V20 H0z M 10 0 A 10 10, 0, 1, 0, 10 20 A 10 10, 0, 1, 0, 10 0z");
        path.set({strokeWidth: 0});
        _canvas.add(path);

    };
    $scope.debug2 = function(){
        var _canvas = $scope.stages[$scope.currentStage]['canvas'];
        var item =  _canvas.getActiveObject();
        
        console.log(item);
//        item.set({
//            top: 0,
//            left: 0,
//            scaleX: 5,
//            scaleY: 5
//        });
//        item.setCoords();
//        $scope.renderStage();
//        console.log(item);
    };
    $scope.renderStage = function(){
        $scope.stages[$scope.currentStage]['canvas'].calcOffset();
        $scope.stages[$scope.currentStage]['canvas'].renderAll();        
    };
    $scope.deactiveAllLayer = function(){
        $scope.stages[$scope.currentStage]['canvas'].discardActiveObject();
        $scope.renderStage();        
    };
    $scope.onAfterAddItem = function( task ){
        var _canvas = this.stages[$scope.currentStage]['canvas'],
        index = _canvas.getObjects().length - 1,
        item = _canvas.item(index),   
        d = new Date(),
        itemId = d.getTime();          
        item.set({"itemId" : itemId});
        switch(task) {
            case 'add':
                _canvas.viewportCenterObject(item);
                item.setCoords();
                var top = item.get('top');
                item.set({top: top - 50});
                item.animate('top', top, {
                    duration: 400,
                    onChange: function(){
                        $scope.renderStage();
                    },
                    onComplete: function(){
                        //if(index == 0){
                            _canvas.setActiveObject(_canvas.item(index)); 
                        //};
                        $scope.renderStage();       
                    },
                    easing: FabricWindow.util.ease['easeInQuad']
                });                
                break;
            case 'duplicate':
                var left = item.get('left'),
                    top =  item.get('top');
                item.set({left: left + 10});
                _canvas.setActiveObject(_canvas.item(index)); 
                item.animate('top', top + 10, {
                    duration: 200,
                    onChange: function(){
                        $scope.renderStage();
                    },
                    onComplete: function(){
                        $scope.renderStage();       
                    },
                    easing: FabricWindow.util.ease['easeInQuad']
                });                 
                break;  
            default: 
                $scope.renderStage();        
        }
        //undo redo
        //update laerys
    };
    $scope.addText = function(){
        $scope.stages[$scope.currentStage]['canvas'].add(new FabricWindow.IText($scope.defaultText, {
            fontFamily: "Roboto",
            radius: 50,
            fontSize: 36,
            noScaleCache: false,
            textDecoration: 'bold',
            spacing: 0
        }));
        //$scope.onAfterAddItem('add');
    };
    $scope.addImage = function(){
        url = 'http://dev.cmsmart.net:3000/wp/wp-content/plugins/web-to-print-online-designer/data/typography/img/23.png';
        fabric.Image.fromURL(url, function(op) {
            op.set({fill: '#ff0000'});
            $scope.stages[$scope.currentStage]['canvas'].add(op);
        });        
    };
    $scope.init();
}]);
nbdApp.factory('FabricWindow', ['$window', function($window) {
    /* Fabric configuration */
    $window.fabric.Object.prototype.set({ 
//        centeredScaling: true,
        transparentCorners: false,
        borderColor: 'rgba(79, 84, 103,0.7)',
        cornerStyle: 'circle',
        cornerColor: 'rgba(255,255,255,1)',
        borderDashArray:[2,2],
        cornerStrokeColor: 'rgba(63, 70, 82,1)',
        fill : '#272c33', 
        borderOpacityWhenMoving: 0
    });
    if( checkMobileDevice() ) $window.fabric.Object.prototype.set({cornerSize: 17});
    $window.fabric.IText.prototype.set({
        cursorWidth: 1,
        cursorColor: '#000',
        selectionColor: "rgba(19, 147, 255, 0.3)",
        cursorDuration: 500    
    });
    $window.fabric.Canvas.prototype.set({
        preserveObjectStacking : true,
        selectionColor: 'rgba(100, 100, 255, 0.5)'
    });        
    return $window.fabric;
}]);
nbdApp.directive('nbdCanvas', ['FabricWindow', '$timeout', '$rootScope', function(FabricWindow, $timeout, $rootScope){
    return {
        restrict: "AE",
        scope: {
            stage: '=stage',
            index: '@'
        },
        link: function( scope, element, attrs ) {
            $timeout(function() {
                scope.stage.canvas = new FabricWindow.Canvas('nbd-stage-'+scope.index);
                scope.$emit('canvas:created', scope.index);
                element.parent().children().on("contextmenu", function(e){
                    e.preventDefault();
                    scope.$emit('nbd:contextmenu', e);
                });
            });          
        }
    }
}]);
nbdApp.directive('keypress', ['$window', function($window){
    return {
        restrict: "AE",
        link: function( scope, element, attrs ) {
            $window.document.addEventListener("keydown", function(e){
                scope.$emit('nbd:keypress', e);
            }, false);           
        }
    }
}]);
nbdApp.filter('keyboardShortcut', function($window) {
    return function(str) {
        if (!str)
            return;
        var keys = str.split('-');
        var isOSX = /Mac OS X/.test($window.navigator.userAgent);
        var seperator = (!isOSX || keys.length > 2) ? '+' : '';
        var abbreviations = {
            M: isOSX ? '⌘' : 'Ctrl',
            A: isOSX ? 'Option' : 'Alt',
            S: 'Shift'
        };
        return keys.map(function (key, index) {
            var last = index == keys.length - 1;
            return last ? key : abbreviations[key];
        }).join(seperator);
    };    
});
nbdApp.factory('NBDDataFactory', function($http){
    return {
        get : function(data, callback) {
            $http({
                method: "POST",
                url: NBDESIGNCONFIG['ajax_url'],
                params: {
                    action: "nbd_get_data",
                    nonce: NBDESIGNCONFIG['nonce_get'],
                    data: data
                }
            }).then(function(success){
                callback(success.data);
            }, function(error){
                alert('Please try again later!');
            })            
        }
    }
});